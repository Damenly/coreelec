From ab07e71de7c6ff45d3dbf1e5b3511042e402a295 Mon Sep 17 00:00:00 2001
From: Arthur Liberman <arthur_liberman@hotmail.com>
Date: Thu, 28 Dec 2023 00:44:36 +0200
Subject: [PATCH 17/18] AMLCodec: Restart codec in `dec_mode=STREAM_TYPE_FRAME`
 on DoVi P7 MEL Dolby Vision Profile 7 Minimum Enhancement Layer (MEL) can't
 use `STREAM_TYPE_STREAM` decoder mode. The kernel can detect MEL content, it
 sets `is_mel=true` in sysfs, we detect it, and restart the codec in the
 correct mode

---
 .../VideoPlayer/DVDCodecs/Video/AMLCodec.cpp  | 47 ++++++++++++++++++-
 .../VideoPlayer/DVDCodecs/Video/AMLCodec.h    |  5 ++
 .../DVDCodecs/Video/DVDVideoCodecAmlogic.cpp  |  6 +++
 .../DVDCodecs/Video/DVDVideoCodecAmlogic.h    |  1 +
 4 files changed, 58 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.cpp
index a5163309b0..7d983d9955 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.cpp
@@ -1812,8 +1812,10 @@ CAMLCodec::CAMLCodec(CProcessInfo &processInfo)
   , m_cur_pts(DVD_NOPTS_VALUE)
   , m_last_pts(DVD_NOPTS_VALUE)
   , m_bufferIndex(-1)
+  , m_bufferIndexStart(UINT_MAX)
   , m_state(0)
   , m_processInfo(processInfo)
+  , m_is_dv_p7_mel(false)
 {
   am_private = new am_private_t;
   memset(am_private, 0, sizeof(am_private_t));
@@ -1865,6 +1867,7 @@ bool CAMLCodec::OpenDecoder(CDVDStreamInfo &hints)
   m_hints.pClock = hints.pClock;
   m_tp_last_frame = std::chrono::system_clock::now();
   m_decoder_timeout = CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_videoDecoderTimeout;
+  m_bufferIndexStart = UINT_MAX;
 
   if (!OpenAmlVideo(hints))
   {
@@ -2020,7 +2023,7 @@ bool CAMLCodec::OpenDecoder(CDVDStreamInfo &hints)
     }
 
     am_private->gcodec.dv_enable = 1;
-    if (hints.dovi.dv_profile == 7 && CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(
+    if (!m_is_dv_p7_mel && hints.dovi.dv_profile == 7 && CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(
         CSettings::SETTING_VIDEOPLAYER_CONVERTDOVI) == 0)
     {
       CSysfsPath amdolby_vision_debug{"/sys/class/amdolby_vision/debug"};
@@ -2377,6 +2380,12 @@ void CAMLCodec::Reset()
   SetPollDevice(am_private->vcodec.cntl_handle);
 }
 
+bool CAMLCodec::Reopen()
+{
+  CloseDecoder();
+  return OpenDecoder(m_hints);
+}
+
 bool CAMLCodec::AddData(uint8_t *pData, size_t iSize, double dts, double pts)
 {
   int data_len, free_len;
@@ -2600,6 +2609,8 @@ int CAMLCodec::DequeueBuffer()
   			static_cast<double>(m_cur_pts) /  DVD_TIME_BASE, vbuf.index);
 
     m_bufferIndex = vbuf.index;
+    if (m_bufferIndexStart == UINT_MAX)
+      m_bufferIndexStart = m_bufferIndex - 1;
   }
   else if (ret != EAGAIN)
   {
@@ -2609,6 +2620,38 @@ int CAMLCodec::DequeueBuffer()
   return ret;
 }
 
+CDVDVideoCodec::VCReturn CAMLCodec::CheckDvP7Mel()
+{
+    if (!m_is_dv_p7_mel && m_bufferIndexStart != UINT_MAX)
+    {
+      m_is_dv_p7_mel = true;
+      if (m_hints.dovi.dv_profile == 7)
+      {
+        CSysfsPath dolby_vision_wait_delay{"/sys/module/amdolby_vision/parameters/dolby_vision_wait_delay"};
+        if (dolby_vision_wait_delay.Exists())
+        {
+          CSysfsPath is_mel{"/sys/module/amdolby_vision/parameters/is_mel"};
+          if (is_mel.Exists())
+          {
+            if (is_mel.Get<char>().value() == 'Y')
+            {
+              CLog::Log(LOGDEBUG, LOGVIDEO, "CAMLCodec::CheckDvP7Mel: DoVi P7 MEL content detected, request to reopen decoder");
+              return CDVDVideoCodec::VC_REOPEN;
+            }
+            else if ((m_bufferIndex - m_bufferIndexStart) <= dolby_vision_wait_delay.Get<unsigned int>().value())
+              m_is_dv_p7_mel = false;
+          }
+          else
+            CLog::Log(LOGERROR, LOGVIDEO, "CAMLCodec::CheckDvP7Mel: is_mel sysfs not found");
+        }
+        else
+          CLog::Log(LOGERROR, LOGVIDEO, "CAMLCodec::CheckDvP7Mel: dolby_vision_wait_delay sysfs not found");
+      }
+    }
+
+    return CDVDVideoCodec::VC_NONE;
+}
+
 CDVDVideoCodec::VCReturn CAMLCodec::GetPicture(VideoPicture *pVideoPicture)
 {
   struct vdec_info vi;
@@ -2646,6 +2689,8 @@ CDVDVideoCodec::VCReturn CAMLCodec::GetPicture(VideoPicture *pVideoPicture)
   }
   else if (m_drain)
     return CDVDVideoCodec::VC_EOF;
+  else if (CheckDvP7Mel() == CDVDVideoCodec::VC_REOPEN)
+    return CDVDVideoCodec::VC_REOPEN;
   else if (buffer_level > 2.0f)
     return CDVDVideoCodec::VC_NONE;
   else if (ret != EAGAIN || elapsed_since_last_frame > std::chrono::seconds(m_decoder_timeout))
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.h
index cfc6fafe31..4adc87aac1 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.h
@@ -66,6 +66,7 @@ public:
   bool          Enable_vadj1();
   void          CloseDecoder();
   void          Reset();
+  bool          Reopen();
 
   bool          AddData(uint8_t *pData, size_t size, double dts, double pts);
   CDVDVideoCodec::VCReturn GetPicture(VideoPicture* pVideoPicture);
@@ -100,6 +101,8 @@ private:
   unsigned int  GetDecoderVideoRate();
   std::string   GetHDRStaticMetadata();
 
+  CDVDVideoCodec::VCReturn CheckDvP7Mel();
+
   DllLibAmCodec   *m_dll;
   bool             m_opened;
   bool             m_drain = false;
@@ -109,6 +112,8 @@ private:
   uint64_t         m_cur_pts;
   uint64_t         m_last_pts;
   uint32_t         m_bufferIndex;
+  uint32_t         m_bufferIndexStart;
+  bool             m_is_dv_p7_mel;
 
   CRect            m_dst_rect;
   CRect            m_display_rect;
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAmlogic.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAmlogic.cpp
index 12f81442d7..a22fce5b74 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAmlogic.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAmlogic.cpp
@@ -436,6 +436,12 @@ void CDVDVideoCodecAmlogic::Reset(void)
     m_bitstream->ResetStartDecode();
 }
 
+void CDVDVideoCodecAmlogic::Reopen(void)
+{
+  Reset();
+  m_Codec->Reopen();
+}
+
 CDVDVideoCodec::VCReturn CDVDVideoCodecAmlogic::GetPicture(VideoPicture* pVideoPicture)
 {
   if (!m_Codec)
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAmlogic.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAmlogic.h
index 8a1d66e485..b0d422909a 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAmlogic.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAmlogic.h
@@ -70,6 +70,7 @@ public:
   virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options) override;
   virtual bool AddData(const DemuxPacket &packet) override;
   virtual void Reset() override;
+  virtual void Reopen() override;
   virtual VCReturn GetPicture(VideoPicture* pVideoPicture) override;
   virtual void SetSpeed(int iSpeed) override;
   virtual void SetCodecControl(int flags) override;
-- 
2.34.1

